<!DOCTYPE html>
<html lang="en">
  <body class="bg-[#070a12] text-white min-h-screen p-6">
    <!-- Controls -->
    <section class="max-w-6xl mx-auto bezel rounded-2xl p-4 mb-6">
      <div class="hud rounded-xl p-4 grid gap-3 md:grid-cols-6 items-end">
        <div>
          <label class="block text-xs opacity-70 lfont">LAT (°)</label>
          <input
            id="lat"
            type="number"
            step="0.0001"
            value="36.083"
            class="inputfx mfont w-full bg-emerald-400/10 text-emerald-200 rounded px-3 py-2 text-xl text-center"
          />
        </div>
        <div>
          <label class="block text-xs opacity-70 lfont">LON (°)</label>
          <input
            id="lon"
            type="number"
            step="0.0001"
            value="-115.152"
            class="inputfx mfont w-full bg-emerald-400/10 text-emerald-200 rounded px-3 py-2 text-xl text-center"
          />
        </div>
        <div>
          <label class="block text-xs opacity-70 lfont">ALT MSL (ft)</label>
          <input
            id="alt"
            type="number"
            step="10"
            value="20000"
            class="inputfx mfont w-full bg-emerald-400/10 text-emerald-200 rounded px-3 py-2 text-xl text-center"
          />
        </div>
        <div>
          <label class="block text-xs opacity-70 lfont">HDG (°)</label>
          <input
            id="hdg"
            type="number"
            step="1"
            value="360"
            class="inputfx mfont w-full bg-emerald-400/10 text-emerald-200 rounded px-3 py-2 text-xl text-center"
          />
        </div>
        <div>
          <label class="block text-xs opacity-70 lfont">SAT LONG (°E)</label>
          <input
            id="satlon"
            type="number"
            step="1"
            value="-129"
            class="inputfx mfont w-full bg-emerald-400/10 text-emerald-200 rounded px-3 py-2 text-xl text-center"
          />
        </div>
        <div class="text-right self-center">
          <div
            id="status"
            class="inline-flex items-center gap-2 px-3 py-2 rounded lfont text-xs tracking-widest bg-emerald-400/10 text-emerald-200"
          >
            LOS OK
          </div>
        </div>

        <!-- Layers -->
        <div class="md:col-span-6 flex flex-wrap items-center gap-4 mt-2">
          <label class="inline-flex items-center gap-2"
            ><input
              id="sh0"
              type="checkbox"
              class="accent-emerald-400"
              checked
            /><span class="text-sm">Show LOS boundary (≥0°)</span></label
          >
          <label class="inline-flex items-center gap-2"
            ><input
              id="sh10"
              type="checkbox"
              class="accent-emerald-400"
              checked
            /><span class="text-sm">Show ≥10° mask</span></label
          >
          <label class="inline-flex items-center gap-2"
            ><input
              id="sh30"
              type="checkbox"
              class="accent-emerald-400"
              checked
            /><span class="text-sm">Show ≥30° mask</span></label
          >
          <div
            class="mfont text-sm text-emerald-300 ml-auto"
            id="maskReadout"
          ></div>
        </div>
      </div>
    </section>

    <!-- Visuals -->
    <section class="max-w-6xl mx-auto grid lg:grid-cols-2 gap-6">
      <!-- Map -->
      <div class="bezel rounded-2xl p-4">
        <div class="hud rounded-xl p-4">
          <div
            class="lfont text-sky-200 tracking-wide text-lg text-center mb-3"
          >
            TOP-DOWN — VISIBILITY CONTOURS
          </div>
          <svg id="map" class="w-full h-[420px] bg-black/35 rounded"></svg>
          <div class="mfont text-xs opacity-70 mt-2">
            Curves show where elevation to this GEO satellite equals 0° (outer),
            10° (middle), 30° (inner). Inside a curve, elevation is ≥ that
            value.
          </div>
        </div>
      </div>

      <!-- Gauges -->
      <div class="grid gap-6">
        <div class="bezel rounded-2xl p-4">
          <div class="hud rounded-xl p-5">
            <div
              class="lfont text-sky-200 tracking-wide text-lg text-center mb-3"
            >
              AZIMUTH (TRUE & REL TO NOSE)
            </div>
            <svg id="compass" class="w-full h-[260px]"></svg>
            <div class="grid grid-cols-2 gap-4 mt-2 mfont text-sm">
              <div>
                Az (true): <span id="azTrue" class="text-emerald-300">—</span>°
              </div>
              <div>
                Az (rel nose):
                <span id="azRel" class="text-emerald-300">—</span>°
              </div>
              <div>
                Slant range: <span id="slant" class="text-emerald-300">—</span>
              </div>
              <div>
                ΔLon: <span id="dlon" class="text-emerald-300">—</span>°
              </div>
            </div>
          </div>
        </div>

        <div class="bezel rounded-2xl p-4">
          <div class="hud rounded-xl p-5">
            <div
              class="lfont text-sky-200 tracking-wide text-lg text-center mb-3"
            >
              ELEVATION TO SAT
            </div>
            <div class="flex items-end gap-6">
              <!-- Vertical elevation bar -->
              <div class="relative w-16 h-56 bg-black/50 rounded-md">
                <!-- tick marks at 0°,10°,30°,60°,90° -->
                <svg id="eTicks" class="absolute inset-0 w-full h-full"></svg>
                <div
                  id="ePointer"
                  class="absolute left-1/2 -translate-x-1/2 w-12 h-[6px] bg-emerald-400 rounded glow"
                ></div>
              </div>
              <div class="mfont text-sm space-y-2">
                <div>
                  Elev: <span id="el" class="text-emerald-300">—</span>°
                </div>
                <div>
                  ≥10°? <span id="ge10" class="text-emerald-300">—</span> ·
                  ≥30°? <span id="ge30" class="text-emerald-300">—</span>
                </div>
                <div>
                  Horizon mask:
                  <span id="mask" class="text-emerald-300">—</span>
                </div>
                <div class="text-xs opacity-70">
                  NO LOS if Elev ≤ 0° (below radio horizon).
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <script>
      // ===== Constants (WGS-84 + GEO) =====
      const a = 6378137.0; // semi-major (m)
      const f = 1 / 298.257223563;
      const e2 = f * (2 - f);
      const GEO_R = 42164137.0; // geostationary radius from Earth's center (m)
      const FT2M = 0.3048,
        M2NM = 1 / 1852;

      // ===== DOM =====
      const el = (id) => document.getElementById(id);
      const latEl = el("lat"),
        lonEl = el("lon"),
        altEl = el("alt"),
        hdgEl = el("hdg"),
        satEl = el("satlon");
      const mapSvg = el("map"),
        compSvg = el("compass"),
        ePtr = el("ePointer"),
        eTicks = el("eTicks"),
        statusEl = el("status");
      const azTrueEl = el("azTrue"),
        azRelEl = el("azRel"),
        slantEl = el("slant"),
        dlonEl = el("dlon"),
        elevEl = el("el"),
        maskEl = el("mask");
      const ge10El = el("ge10"),
        ge30El = el("ge30"),
        maskReadout = el("maskReadout");
      const sh0El = el("sh0"),
        sh10El = el("sh10"),
        sh30El = el("sh30");

      [latEl, lonEl, altEl, hdgEl, satEl, sh0El, sh10El, sh30El].forEach((i) =>
        i.addEventListener("input", render)
      );
      window.addEventListener("resize", render);

      // ===== Math helpers =====
      const d2r = (d) => (d * Math.PI) / 180,
        r2d = (r) => (r * 180) / Math.PI;
      const norm360 = (d) => ((d % 360) + 360) % 360;
      const wrap180 = (d) => ((((d + 180) % 360) + 360) % 360) - 180;

      function geodeticToECEF(lat, lon, h_m) {
        const s = Math.sin(lat),
          c = Math.cos(lat);
        const N = a / Math.sqrt(1 - e2 * s * s);
        return {
          x: (N + h_m) * c * Math.cos(lon),
          y: (N + h_m) * c * Math.sin(lon),
          z: (N * (1 - e2) + h_m) * s,
        };
      }
      function enuFromECEF(lat, lon, dx, dy, dz) {
        const sL = Math.sin(lon),
          cL = Math.cos(lon);
        const sB = Math.sin(lat),
          cB = Math.cos(lat);
        const t = [
          [-sL, cL, 0],
          [-sB * cL, -sB * sL, cB],
          [cB * cL, cB * sL, sB],
        ];
        return {
          e: t[0][0] * dx + t[0][1] * dy + t[0][2] * dz,
          n: t[1][0] * dx + t[1][1] * dy + t[1][2] * dz,
          u: t[2][0] * dx + t[2][1] * dy + t[2][2] * dz,
        };
      }

      // Elevation (deg) at lat,lon to GEO at satLon (deg E)
      function elevationAt(lat_deg, lon_deg, satLon_deg) {
        const lat = d2r(lat_deg),
          lon = d2r(lon_deg),
          satLon = d2r(satLon_deg);
        const obs = geodeticToECEF(lat, lon, 0);
        const sat = {
          x: GEO_R * Math.cos(satLon),
          y: GEO_R * Math.sin(satLon),
          z: 0,
        };
        const dx = sat.x - obs.x,
          dy = sat.y - obs.y,
          dz = sat.z - obs.z;
        const enu = enuFromECEF(lat, lon, dx, dy, dz);
        return r2d(Math.atan2(enu.u, Math.hypot(enu.e, enu.n)));
      }

      // For a given elevation threshold e0, compute cos(gamma) target "u"
      // from tan e = (u - ρ)/sqrt(1 - u^2), where ρ = Re/Rgeo (spherical approx).
      const rho = a / GEO_R; // ~0.1513
      function cosGammaForElev(e0_deg) {
        const t = Math.tan(d2r(e0_deg));
        const A = 1 + t * t,
          B = -2 * rho,
          C = rho * rho - t * t;
        const disc = B * B - 4 * A * C;
        // two roots; we want the physically relevant (larger) one
        const u1 = (-B + Math.sqrt(disc)) / (2 * A);
        return Math.max(-1, Math.min(1, u1));
      }

      // Build two polylines (east/west branches) of the contour: cosφ cosΔλ = u_e
      function contourForElevation(e0_deg, satLon_deg, latStep = 1) {
        const u = cosGammaForElev(e0_deg);
        const east = [],
          west = [];
        const latMax = r2d(Math.acos(Math.min(1, Math.max(-1, u)))); // where cosφ = u -> Δλ=0
        for (
          let φ = -Math.min(80, latMax);
          φ <= Math.min(80, latMax);
          φ += latStep
        ) {
          const cφ = Math.cos(d2r(φ));
          // if |u| > |cosφ|, no solution (outside contour domain)
          if (Math.abs(u) > Math.abs(cφ)) continue;
          const cosD = Math.min(1, Math.max(-1, u / cφ));
          const Δ = r2d(Math.acos(cosD));
          const lonE = wrap180(satLon_deg + Δ);
          const lonW = wrap180(satLon_deg - Δ);
          east.push({ lat: φ, lon: lonE });
          west.push({ lat: φ, lon: lonW });
        }
        return { east, west };
      }

      function computePointing() {
        const lat = d2r(parseFloat(latEl.value || 0));
        const lon = d2r(parseFloat(lonEl.value || 0));
        const alt = parseFloat(altEl.value || 0) * FT2M || 0;
        const hdg = norm360(parseFloat(hdgEl.value || 0));
        const satLon = d2r(parseFloat(satEl.value || 0));

        // Observer ECEF
        const obs = geodeticToECEF(lat, lon, alt);
        // GEO satellite ECEF
        const sat = {
          x: GEO_R * Math.cos(satLon),
          y: GEO_R * Math.sin(satLon),
          z: 0,
        };

        const dx = sat.x - obs.x,
          dy = sat.y - obs.y,
          dz = sat.z - obs.z;
        const slant_m = Math.hypot(dx, dy, dz);

        // Local ENU and angles
        const enu = enuFromECEF(lat, lon, dx, dy, dz);
        const azTrue = norm360(r2d(Math.atan2(enu.e, enu.n)));
        const el = r2d(Math.atan2(enu.u, Math.hypot(enu.e, enu.n)));
        const azRel = wrap180(azTrue - hdg);

        const dlon = wrap180(r2d(satLon - lon));
        return { azTrue, azRel, el, slant_m, dlon, lat, lon, satLon };
      }

      // ===== Map drawing (equirectangular) =====
      function drawMap(lat_deg, lon_deg, satLon_deg, show0, show10, show30) {
        const w = mapSvg.clientWidth,
          h = mapSvg.clientHeight;
        mapSvg.innerHTML = "";
        const NS = "http://www.w3.org/2000/svg";

        const base = document.createElementNS(NS, "image");
        base.setAttribute(
          "href",
          "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQXKJTfY7-EAqV822qZB49bS1lDf6Qzxu-2nQ&s"
        );
        base.setAttribute("x", "0");
        base.setAttribute("y", "0");
        base.setAttribute("width", w);
        base.setAttribute("height", h);
        base.setAttribute("preserveAspectRatio", "none");
        mapSvg.appendChild(base);

        // grid
        for (let lon = -180; lon <= 180; lon += 30) {
          const x = ((lon + 180) / 360) * w;
          const p = document.createElementNS(NS, "path");
          p.setAttribute("d", `M${x},0 V${h}`);
          p.setAttribute("stroke", "rgba(180,220,255,.10)");
          mapSvg.appendChild(p);
          const t = document.createElementNS(NS, "text");
          t.setAttribute("x", x + 2);
          t.setAttribute("y", 12);
          t.setAttribute("fill", "rgba(200,255,255,.6)");
          t.setAttribute("font-size", "10");
          t.textContent = lon;
          mapSvg.appendChild(t);
        }
        for (let lat = -60; lat <= 60; lat += 15) {
          const y = ((90 - lat) / 180) * h;
          const p = document.createElementNS(NS, "path");
          p.setAttribute("d", `M0,${y} H${w}`);
          p.setAttribute("stroke", "rgba(180,220,255,.10)");
          mapSvg.appendChild(p);
          const t = document.createElementNS(NS, "text");
          t.setAttribute("x", 4);
          t.setAttribute("y", y - 2);
          t.setAttribute("fill", "rgba(200,255,255,.6)");
          t.setAttribute("font-size", "10");
          t.textContent = lat;
          mapSvg.appendChild(t);
        }

        // Equator line
        const yEq = ((90 - 0) / 180) * h;
        const eq = document.createElementNS(NS, "path");
        eq.setAttribute("d", `M0,${yEq} H${w}`);
        eq.setAttribute("stroke", "rgba(56,189,248,.45)");
        eq.setAttribute("stroke-dasharray", "6 6");
        mapSvg.appendChild(eq);

        const proj = (lat, lon) => ({
          x: ((lon + 180) / 360) * w,
          y: ((90 - lat) / 180) * h,
        });

        // Contours
        function drawContour(elev, color, dash) {
          const { east, west } = contourForElevation(elev, satLon_deg, 1);
          const toPath = (pts) =>
            pts
              .map(
                (p, i) =>
                  (i ? "L" : "M") +
                  proj(p.lat, p.lon).x +
                  "," +
                  proj(p.lat, p.lon).y
              )
              .join(" ");
          if (east.length > 1) {
            const pe = document.createElementNS(NS, "path");
            pe.setAttribute("d", toPath(east));
            pe.setAttribute("stroke", color);
            pe.setAttribute("stroke-width", "2");
            if (dash) pe.setAttribute("stroke-dasharray", dash);
            pe.setAttribute("fill", "none");
            mapSvg.appendChild(pe);
          }
          if (west.length > 1) {
            const pw = document.createElementNS(NS, "path");
            pw.setAttribute("d", toPath(west));
            pw.setAttribute("stroke", color);
            pw.setAttribute("stroke-width", "2");
            if (dash) pw.setAttribute("stroke-dasharray", dash);
            pw.setAttribute("fill", "none");
            mapSvg.appendChild(pw);
          }
        }

        if (show0) drawContour(0, "rgba(16,185,129,.95)", "6 6"); // LOS boundary
        if (show10) drawContour(10, "rgba(56,189,248,.9)", "4 6"); // ≥10°
        if (show30) drawContour(30, "rgba(251,191,36,.95)", "3 5"); // ≥30°

        // Aircraft to subsat line
        const ac = proj(lat_deg, lon_deg);
        const ss = proj(0, satLon_deg);
        const link = document.createElementNS(NS, "path");
        link.setAttribute("d", `M${ac.x},${ac.y} L${ss.x},${ss.y}`);
        link.setAttribute("stroke", "rgba(16,185,129,.65)");
        link.setAttribute("stroke-width", "2");
        mapSvg.appendChild(link);

        // aircraft marker
        const tri = document.createElementNS(NS, "path");
        tri.setAttribute(
          "d",
          `M${ac.x - 7},${ac.y + 8} L${ac.x},${ac.y - 10} L${ac.x + 7},${
            ac.y + 8
          } Z`
        );
        tri.setAttribute("fill", "rgba(255,255,255,.95)");
        mapSvg.appendChild(tri);

        // sub-sat point
        const satMark = document.createElementNS(NS, "rect");
        satMark.setAttribute("x", ss.x - 5);
        satMark.setAttribute("y", ss.y - 5);
        satMark.setAttribute("width", 10);
        satMark.setAttribute("height", 10);
        satMark.setAttribute("fill", "rgba(251,191,36,.95)");
        mapSvg.appendChild(satMark);

        // Legend
        const legend = document.createElementNS(NS, "g");
        const items = [
          ["LOS (0°)", "rgba(16,185,129,.95)", "6 6"],
          ["≥10°", "rgba(56,189,248,.9)", "4 6"],
          ["≥30°", "rgba(251,191,36,.95)", "3 5"],
        ];
        items.forEach((it, i) => {
          const y = 20 + i * 18;
          const line = document.createElementNS(NS, "path");
          line.setAttribute("d", `M10,${y} H60`);
          line.setAttribute("stroke", it[1]);
          line.setAttribute("stroke-width", "3");
          line.setAttribute("stroke-dasharray", it[2]);
          legend.appendChild(line);
          const t = document.createElementNS(NS, "text");
          t.setAttribute("x", 70);
          t.setAttribute("y", y + 4);
          t.setAttribute("fill", "rgba(200,255,255,.8)");
          t.setAttribute("font-size", "11");
          t.textContent = it[0];
          legend.appendChild(t);
        });
        mapSvg.appendChild(legend);
      }

      // ===== Compass gauge =====
      function drawCompass(azTrue, azRel, hdg) {
        const w = compSvg.clientWidth,
          h = compSvg.clientHeight;
        compSvg.innerHTML = "";
        const NS = "http://www.w3.org/2000/svg";
        const cx = w / 2,
          cy = h / 2,
          R = Math.min(w, h) / 2 - 20;

        // ring
        const ring = document.createElementNS(NS, "circle");
        ring.setAttribute("cx", cx);
        ring.setAttribute("cy", cy);
        ring.setAttribute("r", R);
        ring.setAttribute("fill", "rgba(0,0,0,.35)");
        ring.setAttribute("stroke", "rgba(180,220,255,.2)");
        compSvg.appendChild(ring);

        // ticks + labels
        for (let b = 0; b < 360; b += 10) {
          const L = b % 30 === 0 ? 10 : 5;
          const a = d2r(90 - b);
          const x1 = cx + (R - L) * Math.cos(a),
            y1 = cy - (R - L) * Math.sin(a);
          const x2 = cx + R * Math.cos(a),
            y2 = cy - R * Math.sin(a);
          const p = document.createElementNS(NS, "path");
          p.setAttribute("d", `M${x1},${y1} L${x2},${y2}`);
          p.setAttribute("stroke", "rgba(180,220,255,.3)");
          compSvg.appendChild(p);
          if (b % 30 === 0) {
            const tx = cx + (R - 22) * Math.cos(a),
              ty = cy - (R - 22) * Math.sin(a) + 4;
            const t = document.createElementNS(NS, "text");
            t.setAttribute("x", tx);
            t.setAttribute("y", ty);
            t.setAttribute("fill", "rgba(200,255,255,.7)");
            t.setAttribute("font-size", "11");
            t.setAttribute("text-anchor", "middle");
            t.textContent =
              b === 0
                ? "N"
                : b === 90
                ? "E"
                : b === 180
                ? "S"
                : b === 270
                ? "W"
                : b;
            compSvg.appendChild(t);
          }
        }

        // heading bug (nose)
        const aH = d2r(90 - hdg);
        const hx = cx + (R - 6) * Math.cos(aH),
          hy = cy - (R - 6) * Math.sin(aH);
        const head = document.createElementNS(NS, "circle");
        head.setAttribute("cx", hx);
        head.setAttribute("cy", hy);
        head.setAttribute("r", 6);
        head.setAttribute("fill", "rgba(56,189,248,.9)");
        compSvg.appendChild(head);

        // az true pointer
        const aT = d2r(90 - azTrue);
        const tx = cx + (R - 2) * Math.cos(aT),
          ty = cy - (R - 2) * Math.sin(aT);
        const ptr = document.createElementNS(NS, "path");
        ptr.setAttribute("d", `M${tx},${ty} l-8,0 l8,14 l8,-14 Z`);
        ptr.setAttribute("fill", "rgba(16,185,129,.95)");
        compSvg.appendChild(ptr);

        // center cross
        const c1 = document.createElementNS(NS, "path");
        c1.setAttribute(
          "d",
          `M${cx - 8},${cy} L${cx + 8},${cy} M${cx},${cy - 8} L${cx},${cy + 8}`
        );
        c1.setAttribute("stroke", "rgba(255,255,255,.8)");
        compSvg.appendChild(c1);
      }

      // ===== Elevation bar with ticks =====
      function drawElevationTicks() {
        const w = eTicks.clientWidth,
          h = eTicks.clientHeight;
        eTicks.innerHTML = "";
        const NS = "http://www.w3.org/2000/svg";
        const minE = -5,
          maxE = 90;
        const yFor = (deg) => {
          const t = (deg - minE) / (maxE - minE);
          return (1 - Math.max(0, Math.min(1, t))) * h;
        };

        const marks = [
          { deg: 0, color: "rgba(16,185,129,.9)", label: "0°" },
          { deg: 10, color: "rgba(56,189,248,.9)", label: "10°" },
          { deg: 30, color: "rgba(251,191,36,.95)", label: "30°" },
          { deg: 60, color: "rgba(200,255,255,.3)", label: "60°" },
          { deg: 90, color: "rgba(200,255,255,.3)", label: "90°" },
        ];
        marks.forEach((m) => {
          const y = yFor(m.deg);
          const p = document.createElementNS(NS, "path");
          p.setAttribute("d", `M4,${y} H60`);
          p.setAttribute("stroke", m.color);
          p.setAttribute("stroke-width", "2");
          p.setAttribute("stroke-dasharray", m.deg <= 30 ? "4 4" : "2 6");
          eTicks.appendChild(p);

          const t = document.createElementNS(NS, "text");
          t.setAttribute("x", 64);
          t.setAttribute("y", y + 4);
          t.setAttribute("fill", "rgba(200,255,255,.75)");
          t.setAttribute("font-size", "11");
          t.textContent = m.label;
          eTicks.appendChild(t);
        });
      }

      function drawElevationBar(elev_deg) {
        const minE = -5,
          maxE = 90;
        const box = ePtr.parentElement.getBoundingClientRect();
        const H = box.height;
        const t = (elev_deg - minE) / (maxE - minE);
        const y = (1 - Math.max(0, Math.min(1, t))) * (H - 6);
        ePtr.style.top = `${y}px`;

        // LOS status
        if (elev_deg <= 0) {
          ePtr.style.background = "rgba(239,68,68,.95)"; // red
          statusEl.textContent = "NO LOS";
          statusEl.className =
            "inline-flex items-center gap-2 px-3 py-2 rounded lfont text-xs tracking-widest bg-red-400/10 text-red-300";
          maskEl.textContent = "Below horizon";
        } else {
          ePtr.style.background = "rgba(16,185,129,.95)"; // green
          statusEl.textContent = "LOS OK";
          statusEl.className =
            "inline-flex items-center gap-2 px-3 py-2 rounded lfont text-xs tracking-widest bg-emerald-400/10 text-emerald-200";
          maskEl.textContent = "Clear";
        }
      }

      // ===== Main render =====
      function render() {
        drawElevationTicks();

        const {
          azTrue,
          azRel,
          el: elev,
          slant_m,
          dlon,
          lat,
          lon,
          satLon,
        } = computePointing();

        // Readouts
        azTrueEl.textContent = azTrue.toFixed(1);
        azRelEl.textContent = azRel.toFixed(1);
        slantEl.textContent = `${(slant_m * M2NM).toFixed(1)} NM (${(
          slant_m / 1000
        ).toFixed(0)} km)`;
        dlonEl.textContent = dlon.toFixed(1);
        elevEl.textContent = elev.toFixed(1);

        // Mask checks
        ge10El.textContent = elev >= 10 ? "YES" : "NO";
        ge10El.style.color = elev >= 10 ? "#86efac" : "#fca5a5";
        ge30El.textContent = elev >= 30 ? "YES" : "NO";
        ge30El.style.color = elev >= 30 ? "#86efac" : "#fca5a5";
        maskReadout.innerHTML = `Meets: <span class="mfont">0°</span> ${
          elev > 0 ? "✅" : "❌"
        } · <span class="mfont">10°</span> ${
          elev >= 10 ? "✅" : "❌"
        } · <span class="mfont">30°</span> ${elev >= 30 ? "✅" : "❌"}`;

        // Visuals
        drawMap(
          r2d(lat),
          r2d(lon),
          r2d(satLon),
          sh0El.checked,
          sh10El.checked,
          sh30El.checked
        );
        drawCompass(azTrue, azRel, norm360(parseFloat(hdgEl.value || 0)));
        drawElevationBar(elev);
      }

      render();
    </script>
  </body>
</html>
